// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract TicTacToe {
    address public player1;
    address public player2;
    address public currentPlayer;
    address public winner;
    bool public gameStarted;
    bool public gameEnded;

    uint256 public constant STAKE_AMOUNT = 50 * 10**6; // 50 USDC (USDC = 6 decimals)
    uint256 public constant TOTAL_BANK = 100 * 10**6;
    IERC20 public usdcToken;

    uint8 public stakeRound;
    uint256 public lastMoveTime;
    uint256 public constant MOVE_TIMEOUT = 10 seconds;

    enum Cell { Empty, X, O }
    Cell[3][3] public board;

    enum Stage { WaitingStakes, ReadyToMove }

    mapping(address => uint256) public balances;
    mapping(uint8 => mapping(address => uint256)) public stakeOffers; // stakeRound => player => stake

    Stage public currentStage;

    event GameStarted(address player1, address player2);
    event StakeMade(address indexed player, uint8 round, uint256 amount);
    event MoveMade(address player, uint8 row, uint8 col);
    event GameWon(address winner);
    event GameDraw();
    event GameReset();

    modifier onlyPlayers() {
        require(msg.sender == player1 || msg.sender == player2, "Not a player");
        _;
    }

    modifier gameActive() {
        require(gameStarted && !gameEnded, "Game not active");
        _;
    }

    constructor(address _usdcAddress) {
        usdcToken = IERC20(_usdcAddress);
    }

    function startGame(address _opponent) external {
        require(!gameStarted, "Game already started");
        require(msg.sender != _opponent, "Cannot play against yourself");

        player1 = msg.sender;
        player2 = _opponent;

        require(
            usdcToken.transferFrom(player1, address(this), STAKE_AMOUNT),
            "Player1 stake failed"
        );
        require(
            usdcToken.transferFrom(player2, address(this), STAKE_AMOUNT),
            "Player2 stake failed"
        );

        balances[player1] = STAKE_AMOUNT;
        balances[player2] = STAKE_AMOUNT;

        gameStarted = true;
        gameEnded = false;
        currentPlayer = address(0);
        currentStage = Stage.WaitingStakes;
        stakeRound = 1;
        lastMoveTime = block.timestamp;

        emit GameStarted(player1, player2);
    }

    function makeStake(uint256 amount) external onlyPlayers gameActive {
        require(currentStage == Stage.WaitingStakes, "Stakes not expected now");
        require(amount <= balances[msg.sender], "Stake exceeds available balance");

        stakeOffers[stakeRound][msg.sender] = amount;

        emit StakeMade(msg.sender, stakeRound, amount);

        // When both players staked
        if (
            stakeOffers[stakeRound][player1] > 0 &&
            stakeOffers[stakeRound][player2] > 0
        ) {
            resolveStake();
        }
    }

    function resolveStake() internal {
        uint256 stake1 = stakeOffers[stakeRound][player1];
        uint256 stake2 = stakeOffers[stakeRound][player2];

        if (stake1 > stake2) {
            currentPlayer = player1;
        } else if (stake2 > stake1) {
            currentPlayer = player2;
        } else {
            if (stakeRound < 3) {
                stakeRound++;
                return; // Request new stakes
            } else {
                // Draw lots
                currentPlayer = random() % 2 == 0 ? player1 : player2;
            }
        }

        balances[player1] -= stake1;
        balances[player2] -= stake2;

        currentStage = Stage.ReadyToMove;
        lastMoveTime = block.timestamp;

        // Reset next stake round
        stakeRound = 1;
        stakeOffers[1][player1] = 0;
        stakeOffers[1][player2] = 0;
    }

    function makeMove(uint8 row, uint8 col) external onlyPlayers gameActive {
        require(currentStage == Stage.ReadyToMove, "Not ready to move");
        require(msg.sender == currentPlayer, "Not your turn");
        require(row < 3 && col < 3, "Invalid cell");
        require(board[row][col] == Cell.Empty, "Cell occupied");

        board[row][col] = msg.sender == player1 ? Cell.X : Cell.O;

        emit MoveMade(msg.sender, row, col);

        if (checkWin()) {
            winner = msg.sender;
            gameEnded = true;
            emit GameWon(winner);
        } else if (isBoardFull()) {
            gameEnded = true;
            emit GameDraw();
        } else {
            currentStage = Stage.WaitingStakes;
            stakeOffers[stakeRound][player1] = 0;
            stakeOffers[stakeRound][player2] = 0;
        }

        lastMoveTime = block.timestamp;
    }

    function resetGame() external onlyPlayers {
        require(gameStarted, "No game in progress");

        for (uint8 i = 0; i < 3; i++) {
            for (uint8 j = 0; j < 3; j++) {
                board[i][j] = Cell.Empty;
            }
        }

        gameEnded = false;
        winner = address(0);
        currentPlayer = address(0);
        currentStage = Stage.WaitingStakes;
        stakeRound = 1;
        stakeOffers[1][player1] = 0;
        stakeOffers[1][player2] = 0;

        lastMoveTime = block.timestamp;

        emit GameReset();
    }

    function forfeitIfTimeout() external gameActive {
        require(block.timestamp > lastMoveTime + MOVE_TIMEOUT, "Too early to forfeit");

        address looser = currentPlayer;
        address winnerAddr = looser == player1 ? player2 : player1;
        winner = winnerAddr;
        gameEnded = true;
        emit GameWon(winner);
    }

    function getBoard() external view returns (Cell[3][3] memory) {
        return board;
    }

    function checkWin() internal view returns (bool) {
        for (uint8 i = 0; i < 3; i++) {
            if (
                board[i][0] != Cell.Empty &&
                board[i][0] == board[i][1] &&
                board[i][1] == board[i][2]
            ) return true;

            if (
                board[0][i] != Cell.Empty &&
                board[0][i] == board[1][i] &&
                board[1][i] == board[2][i]
            ) return true;
        }

        if (
            board[0][0] != Cell.Empty &&
            board[0][0] == board[1][1] &&
            board[1][1] == board[2][2]
        ) return true;

        if (
            board[0][2] != Cell.Empty &&
            board[0][2] == board[1][1] &&
            board[1][1] == board[2][0]
        ) return true;

        return false;
    }

    function isBoardFull() internal view returns (bool) {
        for (uint8 i = 0; i < 3; i++) {
            for (uint8 j = 0; j < 3; j++) {
                if (board[i][j] == Cell.Empty) return false;
            }
        }
        return true;
    }

    function random() internal view returns (uint256) {
        return uint256(
            keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender))
        );
    }
}
